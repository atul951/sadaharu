## Trinity College Scheduler Backend – Architecture & Logic

### Overview

The backend is a Spring Boot application that exposes REST APIs for:

- **Semester-wide master schedule generation** (admin view)
- **Student‑specific schedules and enrollments** (student view)

It uses **SQLite** (via JPA/Hibernate) and **Flyway** for schema migrations. The main entrypoint is `Application` which boots the Spring context and auto‑configures components.

### High‑Level Domain Model

- **Core entities**
  - **`Student` / `Teacher` / `Classroom`**: people and rooms.
  - **`Course`**: catalog entry with `gradeLevelMin/Max`, `hoursPerWeek`, optional `prerequisiteId`, and `specializationId`.
  - **`Semester`**: identified by `id`, `year`, and `orderInYear` (used to select which courses run).
  - **`Specialization`**: links subjects to a required classroom `roomType`.
- **Scheduling entities**
  - **`CourseSection`**
    - A concrete **offering of a course in a specific semester**.
    - Fields: `courseId`, `semesterId`, `sectionNumber`, `hoursPerWeek`, `teacherId`, `classroomId`, `capacity`, `status` (`UNSCHEDULED`, `SCHEDULED`, `ACTIVE`, `COMPLETED`, `CANCELLED`).
  - **`SectionTimeslot`**
    - A single weekly meeting for a section (e.g. Monday 10–11).
    - Fields: `dayOfWeek` (1–5), `start_time`, `end_time`.
  - **`StudentEnrollment`**
    - A student’s registration in a section.
    - Fields: `studentId`, `sectionId`, `status` (`ENROLLED`, `WAITLISTED`, `DROPPED`, `COMPLETED`), timestamps.

The tables for `course_sections`, `section_timeslots`, and `student_enrollments` are created and documented in `V1__create_scheduling_tables.sql`.

### Key Services and Responsibilities

- **`SemesterScheduler` (scheduling engine)**
  - Orchestrates **automatic master schedule generation** for a semester.
  - Steps in `generateSchedule(semesterId)`:
    1. **Demand analysis** via `DemandAnalyzer.analyzeDemand` → map of `Course -> sectionsNeeded`.
    2. **Section creation** via `CourseSectionService.createSections`:
       - Ensures the correct number of `CourseSection` rows exist for each course/semester.
       - Skips creation if sections for that course+semester already exist (idempotent).
       - Sorts sections by priority (more hours/week first, then lower course id).
    3. **Section scheduling** via `scheduleCourseSections`:
       - For each course:
         - Finds the **specialization** and from that:
           - **Eligible teachers** (`TeacherRepository.findBySpecializationId`).
           - **Eligible rooms** (`ClassroomRepository.findByRoomTypeId`).
         - For each section:
           - Iterates through combinations of `(teacher, room, timeslots)` generated by `TimeSlotGenerator`.
           - Uses `TimeSlotService.canAssign` to check all constraints:
             - Teacher availability
             - Room availability
             - No conflicts with existing timeslots
             - Daily limits/college hours and lunch rules
           - On a valid combination, calls `TimeSlotService.assign` to:
             - Persist `SectionTimeslot` rows
             - Set `teacherId`, `classroomId`, and mark section `SCHEDULED`.
    4. Returns a `ScheduleResult` containing:
       - All affected `CourseSection` instances
       - Counts of `scheduled` vs `failed`.
  - The whole process is **transactional**; failures throw a runtime exception with logging.

- **`DemandAnalyzer` (how many sections to create)**
  - Input: `semesterId`.
  - Logic:
    - Loads the `Semester` to know `year` and `orderInYear`.
    - Finds all `Course` records where `semester_order == orderInYear`.
    - For each course:
      - Finds all **active students** with grade level in `[gradeLevelMin, gradeLevelMax]` and matching `year`.
      - Filters students by prerequisites:
        - If the course has a `prerequisiteId`, checks student’s course history via `StudentCourseHistoryRepository.hasPassedCourse`.
      - The number of sections = `ceil(eligibleStudentCount / 10)` (capacity constant).
    - Returns a `Map<Course, Integer>` for `CourseSectionService` and `SemesterScheduler`.

- **`CourseSectionService` (section lifecycle and projections)**
  - **Querying sections**:
    - `getSectionsBySemester(semesterId, courseId?, status?)`:
      - By course, by status, or all sections for a semester.
  - **Creating sections from demand**:
    - `createSections(Map<Course,Integer> demand, Long semesterId)`:
      - For each `(course, sectionCount)`:
        - Looks for existing sections for `(courseId, semesterId)`; reuses them if present.
        - Otherwise creates `sectionCount` new `CourseSection`s with:
          - `sectionNumber` starting from 1
          - `hoursPerWeek` copied from `Course`.
        - Calls `sortByPriority` to ensure hard‑to‑place sections are scheduled first.
  - **Projection to API model**:
    - `getSectionsFromCourseSections(List<CourseSection>)`:
      - Batch‑loads related `Course`, `Teacher`, and `Classroom` entities.
      - Uses `CourseSectionMapper.from` to produce a flattened `Section` model with:
        - course name/code, teacher name, classroom name, hours/week, status, etc.

- **`TimeSlotGenerator` & `TimeSlotService` (time assignment)**
  - `TimeSlotGenerator.generateAllPossibleSlots()`:
    - Produces all valid weekly time slots within **college hours (09:00–17:00)** excluding lunch.
    - Used by `SemesterScheduler` to attempt different combinations per section.
  - `TimeSlotService`:
    - `canAssign(section, teacher, room, timeslot)`:
      - Checks if teacher and classroom are free at that time.
      - Ensures constraints like non‑overlapping and daily limits.
    - `assign(section, teacher, room, timeslotsForSection)`:
      - Persists one `SectionTimeslot` per chosen timeslot.
      - Updates section with teacher, room, and status `SCHEDULED`.

- **`EnrollmentService` (student enrollment rules)**
  - `enrollStudentInCourse(studentId, sectionId)` steps:
    1. Load the `CourseSection` and ensure its status is `SCHEDULED` or `ACTIVE`.
    2. Ensure the **student is not already enrolled** in:
       - The same section
       - Any section of the same course in the same semester.
    3. Validate **prerequisites** via `PrerequisiteValidator`.
    4. Check for **time conflicts** using `SectionTimeslotRepository` and a repository method that detects overlaps.
    5. Enforce **max course load (5 courses/semester)** using `StudentEnrollmentRepository.countActiveEnrollments`.
    6. Check **section capacity**:
       - If full → create a `StudentEnrollment` with status `WAITLISTED`.
       - Otherwise → create a `StudentEnrollment` with status `ENROLLED`.
  - Also provides:
    - `drop(studentId, sectionId)` to drop an enrollment.
    - `getStudentEnrollments(studentId, semesterId)` for schedule queries.
    - `validateEnrollment(studentId, sectionId)` which runs all checks and returns a detailed `EnrollmentValidationResult` without persisting anything.

### REST API Layer

The REST controllers are all under the `com.trinity.scheduler.api` package. They are thin layers that:

- Validate path/query params
- Call the appropriate services
- Map entities/models into DTOs for the frontend

#### Semester schedule APIs – `SemesterScheduleController`

- **`POST /api/semesters/{semesterId}/schedule`**
  - Triggers **schedule generation** for the given semester via `SemesterScheduler.generateSchedule`.
  - Builds a `ScheduleResponse` DTO:
    - `semesterId`, `semesterStartDate`, `semesterEndDate`
    - `sectionsCreated`, `sectionsScheduled`, `failed`
    - **Flattened section list** (`SectionDTO`), each containing:
      - Course, teacher, classroom details
      - Timeslots and status
    - `statistics` map with `total_sections`, `scheduled`, `failed`, and `success_rate`.

- **`GET /api/semesters/{semesterId}`**
  - Returns the **current saved schedule** for that semester.
  - Does **not** run the algorithm; instead:
    - Loads `CourseSection`s via `CourseSectionService.getSectionsBySemester`.
    - Maps to `Section` models and then to `SectionDTO`.
    - Computes statistics (same as above) based on `SCHEDULED` status.

- **`DELETE /api/semesters/{semesterId}/delete`**
  - Uses `SemesterService.revertScheduleData` to **delete all schedule data** for a single semester.

- **`DELETE /api/semesters/all`**
  - Uses `SemesterService.revertAllScheduleData` to **clear all schedule data** across semesters.

#### Student schedule APIs – `StudentScheduleController`

- **`GET /api/students/{studentId}/schedule?semesterId=...`**
  - Returns a `StudentScheduleResponse`:
    - `studentId`, `semesterId`
    - `semesterStartDate`, `semesterEndDate`
    - `sectionCount`
    - List of `SectionDTO` for all sections the student is currently enrolled in.
  - Internally:
    - Calls `EnrollmentService.getStudentEnrollments`.
    - Maps each enrollment’s `section` with `CourseSectionService.getSectionsFromCourseSections`.
    - Uses `CourseSectionMapper` to map to DTOs.

Other controllers (e.g. `StudentController`, `CourseSectionsController`) follow the same pattern: small, resource‑oriented endpoints delegating to services and mapping to DTOs.

### Error Handling & Validation

- **Business rule violations** (e.g. prerequisites not met, time conflicts, capacity exceeded) are signaled by `EnrollmentException` or `IllegalArgumentException`, which are caught by the global exception handler and returned as structured error responses.
- **Flyway** ensures the database schema is always at the expected version on startup.
- **Logging** is used extensively for:
  - Demand analysis (eligible student counts, sections needed).
  - Scheduling decisions (teachers/rooms chosen, failures).
  - Enrollment attempts and conflicts.

### How Frontend and Backend Fit Together

- The frontend calls the backend via HTTP (see `frontend/src/services/api.ts`):
  - **Admin flow**
    - `POST /api/semesters/{semesterId}/schedule` → generate schedule.
    - `GET /api/semesters/{semesterId}` → fetch master schedule.
  - **Student flow**
    - `GET /api/students/{studentId}/schedule` → personal schedule.
    - `GET /api/sections` → available sections for a semester.
    - `POST /api/students/{studentId}/enroll` → enroll in a section, enforcing all backend rules.
    - `GET /api/students/{studentId}/progress` → academic progress used in the UI.

The backend owns all scheduling, conflict detection, and constraint logic; the frontend is a thin client on top of these APIs, responsible for user interaction and visualization.


